<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://whitechiina.github.io/</id>
    <title>White</title>
    <updated>2020-12-17T05:16:17.083Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://whitechiina.github.io/"/>
    <link rel="self" href="https://whitechiina.github.io//atom.xml"/>
    <subtitle>记录学习 记录生活</subtitle>
    <logo>https://whitechiina.github.io//images/avatar.png</logo>
    <icon>https://whitechiina.github.io//favicon.ico</icon>
    <rights>All rights reserved 2020, White</rights>
    <entry>
        <title type="html"><![CDATA[JavaScript中this指向以及改变this指向]]></title>
        <id>https://whitechiina.github.io//post/javascript-zhong-this-zhi-xiang-yi-ji-gai-bian-this-zhi-xiang</id>
        <link href="https://whitechiina.github.io//post/javascript-zhong-this-zhi-xiang-yi-ji-gai-bian-this-zhi-xiang">
        </link>
        <updated>2020-12-17T05:12:30.000Z</updated>
        <content type="html"><![CDATA[<p>关于this指向<br>
首先必须要说的是，this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象（这句话有些问题，后面会解释为什么会有问题，虽然网上大部分的文章都是这样说的，虽然在很多情况下那样去理解不会出什么问题，但是实际上那样理解是不准确的，所以在你理解this的时候会有种琢磨不透的感觉）<br>
例子1<br>
function name(){<br>
var a=&quot;A&quot;;<br>
console.log(this.a);//undefined<br>
console.log(this);//Window<br>
};<br>
name();<br>
按照上面所说的this始终指向的是调用它的对象，这里的函数name实际上是被Window对象所调出来的。所以this.a=undefined;<br>
function name(){<br>
var a=&quot;A&quot;;<br>
alert(this.a);//undefined<br>
alert(this);//Window<br>
};<br>
name();<br>
和上面代码一样，alert 也是Window一个属性，也是Window调出来的。<br>
例子2<br>
var n={<br>
name:&quot;LonJin&quot;,<br>
fn:function(){<br>
console.log(this.name)//LonJin<br>
}<br>
};<br>
n.fn();<br>
这里的this指向的是对象n，因为你调用这个fn是通过n.fn()执行的，那自然指向就是对象n，这里再次强调一点，this的指向在函数创建的时候是决定不了的，在调用的时候才能决定，谁调用的就指向谁，一定要搞清楚这个。</p>
<p>其实例子1和例子2说的并不够准确，下面这个例子就可以推翻上面的理论。</p>
<p>例子3<br>
var n={<br>
name:&quot;LonJin&quot;,<br>
fn:function(){<br>
console.log(this.name)//LonJin<br>
}<br>
};<br>
window.n.fn();<br>
这段代码和上面的那段代码几乎是一样的，但是这里的this为什么不是指向window，如果按照上面的理论，最终this指向的是调用它的对象，这里先说个而外话，window是js中的全局对象，我们创建的变量实际上是给window添加属性，所以这里可以用window.n.fn()。</p>
<p>再来看一段代码</p>
<pre><code>var n={
    a:10,
    b:{
        a:12,
        fn:function(){
            console.log(this.a)//12
        }
    }
};
n.b.fn();
</code></pre>
<p>这里同样也是对象n点出来的，但是同样this并没有执行它，那你肯定会说我一开始说的那些不就都是错误的吗？其实也不是，只是一开始说的不准确，接下来我将补充一句话，我相信你就可以彻底的理解this的指向的问题。<br>
彻底理解this指向<br>
情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window，但是我们这里不探讨严格版的问题，你想了解可以自行上网查找。</p>
<p>情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。</p>
<p>情况3：如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象，例子3可以证明，如果不相信，那么接下来我们继续看几个例子。</p>
<pre><code>var n={
    a:10,
    b:{
        // a:12,
        fn:function(){
            console.log(this.a)//undefined
        }
    }
};
n.b.fn();
</code></pre>
<p>尽管对象b中没有属性a，这个this指向的也是对象b，因为this只会指向它的上一级对象，不管这个对象中有没有this要的东西。还有一种特殊的情况，请看例子4。<br>
例子4<br>
var n={<br>
a:10,<br>
b:{<br>
a:12,<br>
fn:function(){<br>
console.log(this.a)//undefined<br>
console.log(this);//window<br>
}<br>
}<br>
};<br>
var j=n.b.fn;<br>
j();<br>
在这里this指向window，这里就又不明白了，其实还是不理解this永远指向最后调用它的对象，也就是看它执行的时候是谁调用的它，例子4中虽然函数fn是被对象b所引用，但是在将fn赋值给变量j的时候并没有执行所以最终指向的是window，这里和例子3是不一样的，例子3是直接执行了fn。<br>
当this遇到retrun时候<br>
function fn(){<br>
this.user=&quot;LonJin&quot;;<br>
return {}<br>
};<br>
var a=new fn;<br>
console.log(a.user);//underfind<br>
再看一个<br>
function fn(){<br>
this.user=&quot;LonJin&quot;;<br>
return function(){</p>
<pre><code>   }
</code></pre>
<p>};<br>
var a=new fn;<br>
console.log(a.user);//undefined<br>
继续看<br>
function fn(){<br>
this.user=&quot;LonJin&quot;;<br>
return 1<br>
};<br>
var a=new fn;<br>
console.log(a.user);//LonJin<br>
function fn(){<br>
this.user=&quot;LonJin&quot;;<br>
return undefined<br>
};<br>
var a=new fn;<br>
console.log(a.user);//LonJin<br>
如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。</p>
<p>还有一点就是虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。</p>
<p>function fn(){<br>
this.user=&quot;LonJin&quot;;<br>
return null<br>
};<br>
var a=new fn;<br>
console.log(a.user);//LonJin<br>
补充<br>
在严格版中的默认的this不再是window，而是undefined。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://whitechiina.github.io//post/about</id>
        <link href="https://whitechiina.github.io//post/about">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<p>这是关于的页面，可以在这里向世界介绍你！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://whitechiina.github.io//post/hello-gridea</id>
        <link href="https://whitechiina.github.io//post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>